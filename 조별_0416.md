## 프로토타입 체인의 끝

> 두 관계의 속성을 받느냐를 뜻하는 프로토타입('두 객체간의 공유되는 또 하나의 객체')은 기본적으로 아래의 구조와 같은 체인(연결고리)를 가지게 됩니다.
>
> `객체child(최하위)` -> `객체parent` -> `Object.prototype` -> `null`
>
>`Object.prototype`은 객체의 속성을 갖는 모든 객체가 공유하는 객체라고 생각해도 됩니다.
> 
> `프로토타입 체인의 끝`이란 즉 체인으로 연결된 객체들에서 하위에 존재하는 객체의 속성값을 최상단이 `null`까지 가서 확인할 수도 있다는 뜻이됩니다.

<br>

```js
const obj1 = { a: 1};
const obj2 = { b: 2};
const obj3 = { c: 3}; //이렇게 세 개의 객체가 있을때

// `obj3 -> obj2 -> obj1` 과 같이 상속받게 만듬

Object.setPrototypeOf(obj2, obj1); //obj1가 부모, obj2가 자식이 됨
Object.setPrototypeOf(obj3, obj2); 

```
<br><br>

>여기서 `obj3.d` 같은 속성을 확인하려고 할 시, 프로토타입 체인의 끝에 의해서 `null`을 가져오게 됩니다.

<br>

### 속성가리기(Property Shadowing)

<br>

> 그러나 여러개의 객체가 상속된다고 가정할 때, 자식에 있는 객체의 속성과 부모 객체의 속성값이 공유되면 어떻게 될까요?
>
>예시 하단,

```js
const obj1 = { a: 4};
const obj2 = { b: 2};
const obj3 = { c: 3};
const obj4 = { a: 1};
```

> 이렇게 나타내어 진다면 obj1 과 obj4는 같은 속성값이 공유됩니다.
>
> 이 경우 `프로토타입 체인`에 의해서 `obj4.b`(값 2), `obj4.c` (값3) 이지만 `obj4.a`의 값은 여전히 1이 됩니다.
>

### 프로토타입의 간접 변경?

> 자식 객체가 부모 객체의 속성을 변경/ 삭제 / 생성을 간접적으로 할 수 있을까요?
>
> 이는 불가능 합니다. 
> 
> 왜냐하면 위에 설명했다싶이 프로토타입은 공통적으로 사용하는 속성을 편리하게 쓰기 위해 따로 객체라는 통에 보관하는 것입니다.
>
> 즉, 수많은 자식 객체가 한 프로토타입을 공유할 수 있다는 말입니다.
>
> 만약, 그 수많은 한 자식 객체가 프로토타입을 변경/ 수정하게 된다면 큰 혼란이 오게 됩니다.

<br>

```js
const parent = { prop: '😝' };

const child = Object.create(parent);

// 프로토타입 객체의 속성을 간접적으로 삭제하는 것은 불가능합니다.
delete child.prop;
parent.prop; // '😝'

// 프로토타입 객체의 속성을 간접적으로 변경하는 것은 불가능합니다.
child.prop = '💀';
parent.prop; // '😝'
child.prop; // '💀'
```



## 생성자

> 객체를 만들기 위해 1) `객체 리터럴` 2) `Object.create`를 이용했지만, `생성자` 를 통해 객체를 만들어 낼 수 도 있습니다.
>
> `new`라는 키워드를 이용하여 만들어 내는 것입니다.
>
> `생성자` 라는 Object()라는 함수를 사용하여 객체를 생성합니다.
>
> 즉, Object()도 `함수` 라는 이야기가 됩니다.
>
> 참고할 점은 생성자는 대문자를 쓰는게 관례이고/ 함수라는 사실입니다.

```js
const obj = new Object();
```

#### Quick Side Note

- Array, Number, Boolean, Object 모두 생성자라는 사실!


```js
// 생성자 정의
function Person(name) {
  this.name = name;
}

// 생성자를 통한 객체 생성
const person1 = new Person('윤아준');
```

> 위의 코드는 생성자를 사용하여 객체를 만드는 과정을 보여줍니다.
>
> 우선 function Person() 이라는 함수가 정의되어 있습니다. 지금까지는 그냥 함수입니다.
>
> 그러나 컴퓨터가 인식을 하고 내려오다가 `new`를 만나는 순간 컴퓨터는 자동적으로 `빈 객체`를 만들어 냅니다.
>
> `this`안에 그 빈 객체가 저장되게 되고 this는 Person이라는 함수를 통해 만들어진 새로운 name('윤아준')을 만들어내어 다시 그 값을 person1 객체에 저장합니다.
>
> 즉, person1이라는 새로운 객체에는 '윤아준' 이라는 값이 저장되게 됩니다.


### 인스턴스란?

- 위의 예제에서처럼, 새로 생성된 객체 person1을 `인스턴스`라고 합니다.

- **인스턴스**란? `생성자를 통해 생성된 객체` 입니다.

### 생성자와 프로토타입

- 서로 반드시 구분해야 할 게 있습니다.

1. **객체의 프로토타입** : 간단히 부모라고 생각하시면 됩니다. 위에 예시에서 obj1 ~ obj 4의 관계라고 생각하시면 됩니다.

2. **생성자의 프로토타입** : 조금 특별합니다. 예를 들어 Person()이라는 생성자(함수; 객체를 만들어내는 함수)는 자동적으로 프로토타입으로 Person.prototype을 갖고 있습니다. 


> 위의 관계는 
>
> Person이라는 생성자이자, 함수이자, 객체
>
> Person.prototype이라는 객체, 위의 생성자와는 다른 개념의 객체
>
> 즉, Person이라는 생성자 안에서 공통으로 쓰고 싶은 속성 을 따로 보관하는 장소라고 생각해도 됩니다. 


